# OpenAct Config Spec (YAML)

# Top-level manifest
version: "1.0"            # required
metadata: {}               # optional key-value map (free-form)

# Flat connections catalog (aka sources)
connections:
  # Connection name (unique)
  <connection_name>:
    kind: <connector>      # required: http | postgres | mysql | redis | ...
                           # NOTE: use canonical ids as accepted by the loader and registry.
                           # - databases: use "postgres" (not "postgresql"). The build feature is named
                           #   "postgresql", but config kind is "postgres".
    description: "..."     # optional

    # Style A (flattened syntax, recommended for authoring)
    # connector-specific fields go directly under the connection node and are
    # normalized to the `config` map.

    # Style B (explicit config wrapper) - loader normalizes both styles into config
    # config:
    #   ... connector specific fields ...

    # Example: HTTP connection (Style A)
    # kind: http
    # auth_ref: "trn:openact:default:auth/github/alice"   # reference to AuthFlow-generated credential
    # base_url: "https://api.example.com"
    # authorization: "api_key"            # or basic | oauth2 | none
    # auth_parameters:
    #   api_key_auth_parameters:
    #     api_key_name: "X-API-Key"
    #     api_key_value: "${API_KEY}"
    # timeout_config:
    #   connect_ms: 5000
    #   read_ms: 30000
    # http_policy:
    #   follow_redirects: true
    # retry_policy:
    #   max_attempts: 3

    # Example: PostgreSQL connection (Style B)
    # kind: postgres
    # config:
    #   host: "${PG_HOST}"
    #   port: 5432
    #   database: "analytics"
    #   user: "analytics"
    #   password: "${PG_PASSWORD}"
    #   ssl_mode: "require"
    #   connect_timeout_seconds: 10
    #   max_connections: 10
    #   query_params:
    #     search_path: "public"


# Flat actions catalog (aka tools)
actions:
  # Action/tool name (used as default MCP tool name/alias)
  <tool_name>:
    # Action kind may be omitted; if omitted, it inherits the referenced connection's kind.
    # On normalization/export, the system will always materialize an explicit kind.
    kind: <connector>      # optional for authoring, required after normalization

    # Reference to a defined connection
    connection: <connection_name>    # required

    description: "..."     # optional
    metadata: {}           # optional

    # Strongly-typed input parameters (drives validation and MCP inputSchema generation)
    parameters:            # optional
      - name: <param_name>
        type: string|number|boolean|object|array
        required: true|false           # optional (connector-dependent; for Postgres all declared params are required)
        default: <any>                 # optional (used by validators/clients; connector-dependent at runtime)
        description: "..."             # optional
        nullable: true|false           # optional (maps to JSON Schema nullability)
        enum: [a, b, c]               # optional
        format: email|uri|uuid|...     # optional (JSON Schema well-known formats)
        minLength: 1                   # optional (strings)
        maxLength: 128                 # optional (strings)
        pattern: "^[a-z0-9_]+$"        # optional (strings)
        minimum: 0                     # optional (numbers)
        maximum: 100                   # optional (numbers)
        schema: {}                     # optional: full JSON Schema for complex objects/arrays

    # Connector-specific execution config (HTTP/SQL/Redis/...) kept inside config
    config:
      # HTTP action example
      # method: "GET"
      # path: "/resource/{id}"
      # headers:
      #   Authorization: ["Bearer {{token}}"]
      # query_params:
      #   verbose: ["true"]
      # body:
      #   json:
      #     example: true
      # timeout_config:
      #   read_ms: 15000
      # response_policy:
      #   success_status: [200, 201]

      # PostgreSQL action example
      # statement: |
      #   SELECT * FROM table WHERE id = $1;
      # parameters:
      #   - name: id
      #     param_type: "number"
      # result_format: "json"

      # Redis action example
      # command: ["GET", "{{key}}"]          # template placeholders map from parameters

    # Optional MCP exposure and overrides
    mcp:                    # optional
      enabled: true|false
      tool_name: <alias>    # optional; overrides action key in tools/list
      description: "..."     # optional; overrides description for MCP clients
      tags: ["db", "users"] # optional; categorization for discovery/UX
      requires_auth: false  # optional; advisory flag for clients/governance
      input_shape: object|args  # optional; hints preferred input shape for tools/call
      # input_schema: {}     # optional; override derived schema (CURRENTLY EXPERIMENTAL –
                             # wire up only if server side supports it; otherwise prefer parameters → schema)

    # Optional execution limits (connector-dependent; enforced when supported)
    limits:                 # optional
      timeout_ms: 5000      # optional; action-level timeout
      max_rows: 1000        # optional; for query-like actions
      max_bytes: 1048576    # optional; truncate or error past this size
      dry_run: false        # optional; validate/bind only, skip execution if supported


# Normalization & validation rules (comments):
# - Kind inheritance: actions[].kind may be omitted; loader infers from actions[].connection.kind.
#   After loading, an explicit kind is always stored (in-memory/DB) and exported.
# - Kind compatibility: actions[].kind must be compatible with the referenced connection.kind (same family).
# - Style normalization: connections accept flattened fields or config wrapper; loader normalizes to config.
#   actions export use config wrapper for execution details.
# - Env vars: ${VAR_NAME} are resolved at load/import.
# - Names: action keys are globally unique; used as default MCP tool names/aliases and for governance filters.
#   Use stable, semantic names to avoid alias conflicts when combined with mcp.tool_name.

# HTTP connector specifics:
# - Merge precedence (low → high): connection.config < action.config < call input
# - Shallow-merge maps: headers, query_params, cookies (one level). Higher layer overwrites lower layer keys.
#   Deletion: set key: null at higher layer to remove it from the merged result.
# - Whole-object replace: body/auth_parameters/timeout_config/network_config/http_policy/retry_policy.
# - Base URL & routing: base_url comes only from connection; method/path defined per action; call input may supply
#   template variables via input.path.
# - GET/HEAD: request body is ignored (warning emitted). Other methods send body with Content-Type rules:
#     explicit Content-Type honored; otherwise infer (object/array → application/json, string → text/plain).
# - Parameters: path variables auto-derived from `path`; additional parameters defined under `parameters` list.
# - `auth_ref` must point to an entry created by AuthFlow (TRN format `trn:openact:{tenant}:auth/{provider}/{user}`),
#   allowing connectors to reuse OAuth credentials persisted in `auth_connections`.

# PostgreSQL connector specifics:
# - `config` fields map to `PostgresConnection`: host, port, database, user, password, ssl_mode, query_params, etc.
# - Actions require `statement` (supports multiline). Positional parameters use `$1..$N`; named parameters map from
#   action `parameters` or input object keys.
# - Input shapes accepted:
#     * `{ "args": [..] }` positional array matching declared parameters.
#     * Plain object `{ id: 1 }` with keys matching parameter names.
#     * `null` when no parameters are expected.
# - Outputs: SELECT/RETURNING statements emit arrays of row objects; others return `{ "rows_affected": n }`.
# - `limits.max_rows` controls cursor fetch cap; `timeout_ms` maps to query timeout when supported.

# Redis / other connectors should follow similar patterns: document connection config, action config, merge semantics,
# and input/output conventions here when added.

# Parameters (comments):
# - May be defined on both connection and action; merged by name (action overrides). Used for validation & MCP inputSchema.
# - For Postgres actions, declared parameters are treated as required and bound positionally or by name.
#   The loader stores `parameters` into action config (_metadata) to let MCP derive inputSchema.
# - mcp.input_schema: keep as an advanced override only if server supports it; otherwise prefer deriving from `parameters`.

# Input mapping (comments):
# - Recognized input keys: query, headers, body, path, and template variables.
# - Path templating: /users/{id} is filled from input.path.id or by name; missing required vars cause validation errors.
# - For Postgres, inputs can be either `{ args: [..] }` (positional) or an object with parameter names; both are supported.

# Export style (comments):
# - Connections: flattened style by default (or configurable). Actions: config wrapper; explicit kind always present.
# - Statement sugar: actions may specify `statement: "..."` which normalizes into `config.statement` during load.

# Governance (comments):
# - Server-level governance can allow/deny tools by pattern (e.g., ["openact.execute"], ["postgres.*"]).
# - Combine with `mcp.requires_auth` and tags to drive client-side UX or policy engines.
